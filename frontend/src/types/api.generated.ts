/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Health Check
         * @description Health check endpoint - responds immediately even during heavy operations.
         *
         *     Uses a separate monitoring thread to ensure non-blocking responses,
         *     preventing false "connection lost" warnings during TTS model loading.
         *
         *     Also includes engine availability for frontend feature-gating.
         */
        get: operations["health_check_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Root
         * @description Root endpoint
         */
        get: operations["root__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/tts/generate-segment/{segment_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate Segment By Id
         * @description Queue segment for regeneration via worker (Phase 2.5)
         *
         *     This endpoint creates a segment-type job that will be processed by the TTS worker.
         *     The segment's existing parameters (engine, model, speaker, language) are used.
         *
         *     This replaces the old synchronous generation approach to:
         *     - Enable job cancellation
         *     - Prevent request timeouts on long generations
         *     - Maintain consistency with chapter-level generation
         *
         *     Returns immediately with job information.
         *     Use GET /api/tts/progress/{chapter_id} to monitor progress.
         */
        post: operations["generate_segment_by_id_api_tts_generate_segment__segment_id__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/tts/generate-chapter": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate Chapter
         * @description Generate audio for an entire chapter (batch operation)
         *
         *     Creates job in database (persistent) and returns immediately.
         *     Worker picks up job asynchronously. State persists across restarts.
         */
        post: operations["generate_chapter_api_tts_generate_chapter_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/tts/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Tts Jobs
         * @description List TTS jobs with optional filters (database-backed)
         *
         *     Query Parameters:
         *         status: Filter by job status ('pending', 'running', 'completed', 'failed', 'cancelled')
         *         chapter_id: Filter by chapter ID
         *         limit: Maximum number of results (default 50, max 100)
         *         offset: Pagination offset (default 0)
         *
         *     Use Cases:
         *         - Global job list UI (all active jobs): GET /jobs/tts?status=running
         *         - Chapter-specific job history: GET /jobs/tts?chapter_id=xxx
         *         - All active jobs: GET /jobs/tts?status=pending,running (note: comma not supported, use /active)
         *         - Completed jobs: GET /jobs/tts?status=completed&limit=20
         *
         *     Returns:
         *         TTSJobsListResponse with list of jobs matching filters
         */
        get: operations["list_tts_jobs_api_jobs_tts__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/tts/active": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Active Tts Jobs
         * @description Get all active TTS jobs (pending + running + cancelled/paused)
         *
         *     Convenience endpoint optimized for real-time monitoring.
         *     Returns only jobs that are currently pending, running, or paused (cancelled).
         *
         *     This endpoint is designed for:
         *         - Real-time job monitoring UI
         *         - Navbar badge counts
         *         - Auto-polling (500ms-1s interval)
         *
         *     Equivalent to: GET /jobs/tts?status=pending,running,cancelled but more efficient
         *     (single database query instead of multiple status checks)
         *
         *     Returns:
         *         TTSJobsListResponse with only pending/running/cancelled jobs
         */
        get: operations["list_active_tts_jobs_api_jobs_tts_active_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/tts/{job_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Tts Job
         * @description Get single TTS job by ID (database-backed)
         *
         *     Path Parameters:
         *         job_id: Unique job identifier (UUID)
         *
         *     Use Cases:
         *         - Job detail view
         *         - Real-time progress tracking for specific job
         *         - Debugging/troubleshooting
         *
         *     Returns:
         *         TTSJobResponse with complete job details
         *
         *     Raises:
         *         404: Job not found
         */
        get: operations["get_tts_job_api_jobs_tts__job_id__get"];
        put?: never;
        post?: never;
        /**
         * Delete Tts Job
         * @description Delete a specific TTS job by ID
         *
         *     Primarily used for deleting individual cancelled jobs that won't be resumed.
         *     Can also delete any job regardless of status (use with caution).
         *
         *     Path Parameters:
         *         job_id: Unique job identifier (UUID)
         *
         *     Returns:
         *         Confirmation of deletion
         *
         *     Raises:
         *         404: Job not found
         *         500: Database error
         *
         *     Example Response:
         *         {"deleted": true, "job_id": "abc123..."}
         */
        delete: operations["delete_tts_job_api_jobs_tts__job_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/tts/cleanup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Cleanup Tts Jobs
         * @description Delete all completed and failed TTS jobs (bulk cleanup)
         *
         *     Deletes jobs with status 'completed' or 'failed'.
         *     Cancelled jobs are NOT deleted (user might want to resume them).
         *
         *     Use Cases:
         *         - Clear job history to reduce clutter
         *         - Periodic maintenance/cleanup
         *         - Free database space
         *
         *     Returns:
         *         Number of jobs deleted
         *
         *     Example Response:
         *         {"deleted": 15}
         *
         *     Note: This route MUST be defined before /{job_id} to prevent
         *     "cleanup" being matched as a job_id parameter.
         */
        delete: operations["cleanup_tts_jobs_api_jobs_tts_cleanup_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/tts/{job_id}/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cancel Tts Job
         * @description Cancel a TTS job by job ID
         *
         *     For pending jobs: Direct cancellation
         *     For running jobs: Graceful cancellation (worker stops after current segment)
         *
         *     Args:
         *         job_id: Job identifier
         *
         *     Returns:
         *         Cancellation status
         */
        post: operations["cancel_tts_job_api_jobs_tts__job_id__cancel_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/tts/{job_id}/resume": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Resume Tts Job
         * @description Resume a cancelled TTS job by reactivating it with remaining segments
         *
         *     Updates the cancelled job back to 'pending' status and sets it to
         *     process only the segments that were not completed before cancellation.
         *     Preserves the job ID and processed segments count (progress).
         *
         *     Path Parameters:
         *         job_id: UUID of the cancelled job to resume
         *
         *     Returns:
         *         The same job (updated to pending status with new segment list)
         *
         *     Raises:
         *         404: Original job not found
         *         400: Job is not in cancelled status
         *         400: All segments already completed (nothing to resume)
         *
         *     Example Response:
         *         {
         *           "id": "same-job-uuid",  // Same as input job_id
         *           "chapterId": "chapter-123",
         *           "status": "pending",
         *           "totalSegments": 5,  // Only unprocessed segments
         *           "processedSegments": 3,  // Preserved from before cancellation
         *           ...
         *         }
         *
         *     Flow:
         *         1. Load original cancelled job
         *         2. Find segments from that chapter that are not completed
         *         3. Update same job: status='pending', new segment list
         *         4. Worker will pick up the resumed job automatically
         */
        post: operations["resume_tts_job_api_jobs_tts__job_id__resume_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/quality/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Quality Jobs
         * @description List quality jobs with optional filtering.
         *
         *     Supports filtering by status and chapter_id with pagination.
         */
        get: operations["list_quality_jobs_api_jobs_quality__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/quality/active": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Active Quality Jobs
         * @description List active (pending/running) quality jobs.
         *
         *     Optimized endpoint for job monitoring UI.
         */
        get: operations["list_active_quality_jobs_api_jobs_quality_active_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/quality/{job_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Quality Job
         * @description Get quality job by ID.
         *
         *     Returns job details including progress and analysis results.
         */
        get: operations["get_quality_job_api_jobs_quality__job_id__get"];
        put?: never;
        post?: never;
        /**
         * Delete Quality Job
         * @description Delete a quality job.
         *
         *     Removes job from database. Cannot delete running jobs.
         */
        delete: operations["delete_quality_job_api_jobs_quality__job_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/quality/{job_id}/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cancel Quality Job
         * @description Cancel a running quality job.
         *
         *     Pending jobs cancel immediately. Running jobs stop gracefully after current segment.
         */
        post: operations["cancel_quality_job_api_jobs_quality__job_id__cancel_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/quality/cleanup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Cleanup Quality Jobs
         * @description Delete all completed and failed quality jobs (bulk cleanup).
         *
         *     Deletes jobs with status 'completed' or 'failed'.
         *     Cancelled jobs are NOT deleted (user might want to resume them).
         *
         *     Returns:
         *         Number of jobs deleted
         *
         *     Note: This route MUST be defined before /{job_id} to prevent
         *     "cleanup" being matched as a job_id parameter.
         */
        delete: operations["cleanup_quality_jobs_api_jobs_quality_cleanup_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/quality/{job_id}/resume": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Resume Quality Job
         * @description Resume a cancelled quality job.
         *
         *     Resets job to pending status so worker will pick it up again.
         *
         *     Path Parameters:
         *         job_id: UUID of the cancelled job to resume
         *
         *     Returns:
         *         Updated job object
         *
         *     Raises:
         *         404: Job not found
         *         400: Job is not cancelled
         */
        post: operations["resume_quality_job_api_jobs_quality__job_id__resume_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/engines/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get All Engines Status
         * @description Get status of all discovered engines across all types.
         *
         *     Returns engines grouped by type (TTS, Text, STT, Audio) with detailed status info.
         *     Includes feature-gating summary (has_tts_engine, has_text_engine, has_stt_engine).
         *
         *     Returns:
         *         AllEnginesStatusResponse with engines grouped by type
         */
        get: operations["get_all_engines_status_api_engines_status_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/engines/{engine_type}/{engine_name}/enable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Enable Engine
         * @description Enable an engine
         *
         *     Args:
         *         engine_type: Type of engine ('tts', 'text', 'stt', 'audio')
         *         engine_name: Engine identifier
         *
         *     Returns:
         *         Success message
         */
        post: operations["enable_engine_api_engines__engine_type___engine_name__enable_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/engines/{engine_type}/{engine_name}/disable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Disable Engine
         * @description Disable an engine
         *
         *     Validates that default TTS engine cannot be disabled.
         *
         *     Args:
         *         engine_type: Type of engine ('tts', 'text', 'stt', 'audio')
         *         engine_name: Engine identifier
         *
         *     Returns:
         *         Success message
         *
         *     Raises:
         *         400: If trying to disable default TTS engine
         */
        post: operations["disable_engine_api_engines__engine_type___engine_name__disable_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/engines/{engine_type}/{engine_name}/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start Engine
         * @description Manually start an engine server
         *
         *     Args:
         *         engine_type: Type of engine ('tts', 'text', 'stt', 'audio')
         *         engine_name: Engine identifier
         *         request: Optional request body with model_name
         *
         *     Returns:
         *         Success message with port number
         *
         *     Raises:
         *         400: If engine is disabled or not found
         *         500: If engine start failed
         */
        post: operations["start_engine_api_engines__engine_type___engine_name__start_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/engines/{engine_type}/{engine_name}/stop": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Stop Engine
         * @description Manually stop an engine server
         *
         *     Args:
         *         engine_type: Type of engine ('tts', 'text', 'stt', 'audio')
         *         engine_name: Engine identifier
         *
         *     Returns:
         *         Success message
         *
         *     Raises:
         *         400: If engine not found
         *         500: If engine stop failed
         */
        post: operations["stop_engine_api_engines__engine_type___engine_name__stop_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/engines/{engine_type}/default/{engine_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Set Default Engine
         * @description Set the default engine for a given type
         *
         *     Args:
         *         engine_type: Type of engine ('tts', 'stt', 'text')
         *         engine_name: Engine identifier to set as default
         *
         *     Returns:
         *         Success message
         *
         *     Raises:
         *         400: If engine is disabled or not found
         */
        post: operations["set_default_engine_api_engines__engine_type__default__engine_name__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/engines/{engine_type}/default": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Clear Default Engine
         * @description Clear the default engine for a given type (set to none)
         *
         *     Note: TTS must always have a default engine, so this will fail for TTS.
         *
         *     Args:
         *         engine_type: Type of engine ('stt', 'text', 'audio')
         *
         *     Returns:
         *         Success message
         *
         *     Raises:
         *         400: If trying to clear TTS default (not allowed)
         */
        delete: operations["clear_default_engine_api_engines__engine_type__default_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/engines/{engine_type}/{engine_name}/keep-running": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Set Engine Keep Running
         * @description Set keep-running flag for an engine
         *
         *     Engines with keepRunning=true will not be auto-stopped after inactivity.
         *
         *     Args:
         *         engine_type: Type of engine ('tts', 'text', 'stt', 'audio')
         *         engine_name: Engine identifier
         *         request: Request body with keepRunning boolean
         *
         *     Returns:
         *         Success message
         *
         *     Raises:
         *         400: If engine type is invalid or engine not found
         *         500: If operation failed
         */
        post: operations["set_engine_keep_running_api_engines__engine_type___engine_name__keep_running_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/projects": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get All Projects
         * @description Get all projects with their chapters and segments.
         *
         *     Returns full project hierarchy for sidebar and project selection.
         */
        get: operations["get_all_projects_api_projects_get"];
        put?: never;
        /**
         * Create Project
         * @description Create a new project.
         *
         *     Broadcasts project.created SSE event.
         */
        post: operations["create_project_api_projects_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/projects/{project_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Project
         * @description Get a single project with chapters and segments.
         *
         *     Returns full project hierarchy for detail view.
         */
        get: operations["get_project_api_projects__project_id__get"];
        /**
         * Update Project
         * @description Update project title and description.
         *
         *     Broadcasts project.updated SSE event.
         */
        put: operations["update_project_api_projects__project_id__put"];
        post?: never;
        /**
         * Delete Project
         * @description Delete a project and all its audio files.
         *
         *     Cascade deletes chapters, segments, and pronunciation rules.
         *     Broadcasts project.deleted SSE event.
         */
        delete: operations["delete_project_api_projects__project_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/projects/reorder": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reorder Projects
         * @description Reorder projects
         *
         *     Request body:
         *     {
         *       "project_ids": ["id1", "id2", "id3"]
         *     }
         *
         *     Array index = new position (0, 1, 2, ...)
         */
        post: operations["reorder_projects_api_projects_reorder_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/chapters": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Chapter
         * @description Create a new chapter.
         *
         *     Broadcasts chapter.created SSE event.
         */
        post: operations["create_chapter_api_chapters_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/chapters/{chapter_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Chapter
         * @description Get a chapter with its segments.
         *
         *     Used for chapter detail view and segment list rendering.
         */
        get: operations["get_chapter_api_chapters__chapter_id__get"];
        /**
         * Update Chapter
         * @description Update chapter title and order.
         *
         *     Broadcasts chapter.updated SSE event.
         */
        put: operations["update_chapter_api_chapters__chapter_id__put"];
        post?: never;
        /**
         * Delete Chapter
         * @description Delete a chapter and its audio files.
         *
         *     Cascade deletes all segments. Broadcasts chapter.deleted SSE event.
         */
        delete: operations["delete_chapter_api_chapters__chapter_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/chapters/{chapter_id}/segment": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Segment Chapter Text
         * @description Segment chapter text into natural segments using text engine and create them in the database
         *
         *     Args:
         *         chapter_id: Chapter ID to segment
         *         request: Segmentation parameters (including engine for constraint detection)
         *
         *     Returns:
         *         Created segments with validation status
         */
        post: operations["segment_chapter_text_api_chapters__chapter_id__segment_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/chapters/reorder": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reorder Chapters
         * @description Reorder chapters within a project.
         *
         *     Array index determines new position. Broadcasts chapter.reordered SSE event.
         */
        post: operations["reorder_chapters_api_chapters_reorder_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/chapters/{chapter_id}/move": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Move Chapter
         * @description Move chapter to another project.
         *
         *     Updates project_id and reorders chapters in both source and target projects.
         */
        put: operations["move_chapter_api_chapters__chapter_id__move_put"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/segments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Segment
         * @description Create a new segment
         *
         *     Supports two types:
         *     - standard: Regular text segment (requires engine, model_name, language)
         *     - divider: Pause/scene break (only needs pause_duration)
         */
        post: operations["create_segment_api_segments_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/segments/{segment_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Segment
         * @description Get a single segment by ID.
         *
         *     Used for segment detail view and editing.
         */
        get: operations["get_segment_api_segments__segment_id__get"];
        /**
         * Update Segment
         * @description Update segment text, audio, or TTS parameters.
         *
         *     Deletes quality analysis if text changes. Broadcasts segment.updated SSE event.
         */
        put: operations["update_segment_api_segments__segment_id__put"];
        post?: never;
        /**
         * Delete Segment
         * @description Delete a segment and its audio file.
         *
         *     Deletes audio file and quality analysis. Broadcasts segment.deleted and chapter.updated SSE events.
         */
        delete: operations["delete_segment_api_segments__segment_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/segments/reorder": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reorder Segments
         * @description Reorder segments within a chapter.
         *
         *     Array index determines new position. Broadcasts segment.reordered SSE event.
         */
        post: operations["reorder_segments_api_segments_reorder_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/segments/{segment_id}/move": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Move Segment
         * @description Move segment to another chapter.
         *
         *     Updates chapter_id and reorders segments in both source and target chapters.
         */
        put: operations["move_segment_api_segments__segment_id__move_put"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/segments/{segment_id}/freeze": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Toggle Freeze Segment
         * @description Freeze or unfreeze a segment.
         *
         *     Frozen segments are:
         *     - Protected from regeneration (TTS jobs skip them)
         *     - Protected from STT analysis
         *     - Visually marked with blue background + checkmark
         *
         *     Request body:
         *     {
         *       "freeze": true  // or false
         *     }
         */
        patch: operations["toggle_freeze_segment_api_segments__segment_id__freeze_patch"];
        trace?: never;
    };
    "/api/text/segment": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Segment Text
         * @description Segment text using the configured text processing engine.
         *
         *     Args:
         *         request: Segmentation parameters
         *
         *     Returns:
         *         List of text segments
         */
        post: operations["segment_text_api_text_segment_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audio/export": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start Export
         * @description Start audio export for a chapter
         *
         *     This endpoint initiates a background export job that:
         *     1. Validates all segments are completed
         *     2. Merges segment audio files with pauses
         *     3. Converts to the requested format
         *     4. Adds metadata (title, track number)
         */
        post: operations["start_export_api_audio_export_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audio/export/{job_id}/progress": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Export Progress
         * @description Get progress of an export job
         *
         *     Returns current status and progress information for tracking
         *     the export operation in the UI.
         */
        get: operations["get_export_progress_api_audio_export__job_id__progress_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audio/export/{job_id}/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Cancel Export
         * @description Cancel a running export job
         *
         *     Attempts to stop an in-progress export operation.
         */
        delete: operations["cancel_export_api_audio_export__job_id__cancel_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audio/export/{job_id}/download": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download Export
         * @description Download the exported audio file
         *
         *     Returns the exported file for download once the job is completed.
         */
        get: operations["download_export_api_audio_export__job_id__download_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audio/export/{job_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete Export
         * @description Delete export file and cleanup resources
         *
         *     Called after successful download or when user cancels/closes dialog.
         *     Removes the exported audio file and any temporary files.
         */
        delete: operations["delete_export_api_audio_export__job_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audio/merge": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Merge Segments
         * @description Quick merge for preview (no format conversion)
         *
         *     Creates a temporary WAV file for immediate playback
         *
         *     Request body (camelCase or snake_case accepted):
         *     {
         *       "chapterId": "chapter-123",
         *       "pauseMs": 500
         *     }
         */
        post: operations["merge_segments_api_audio_merge_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audio/duration/{file_path}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Audio Duration
         * @description Get duration of an audio file
         */
        get: operations["get_audio_duration_api_audio_duration__file_path__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audio/{file_path}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Audio File
         * @description Serve audio files with proper CORS headers
         *
         *     This endpoint serves audio files from the output directory.
         *     Using an explicit endpoint instead of StaticFiles mount ensures
         *     CORS middleware is applied correctly.
         *
         *     IMPORTANT: This is a catch-all route and must be defined LAST
         *     to avoid shadowing other routes like /duration/{file_path}
         */
        get: operations["get_audio_file_api_audio__file_path__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/settings/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get All Settings
         * @description Get all global settings
         *
         *     Returns all settings organized by category (general, tts, audio, text).
         */
        get: operations["get_all_settings_api_settings__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/settings/{key}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Setting
         * @description Get specific setting by key
         *
         *     Supports both top-level keys (e.g., 'tts') and dot-notation (e.g., 'tts.defaultEngine').
         *
         *     Args:
         *         key: Setting key
         *
         *     Returns:
         *         Setting value
         */
        get: operations["get_setting_api_settings__key__get"];
        /**
         * Update Setting
         * @description Update a setting
         *
         *     Updates a top-level category (e.g., 'tts', 'audio') with new values.
         *     The entire category object is replaced.
         *
         *     Args:
         *         key: Setting category key
         *         request: New value for the category
         *
         *     Returns:
         *         Updated setting
         */
        put: operations["update_setting_api_settings__key__put"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/settings/reset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset To Defaults
         * @description Reset all settings to default values
         *
         *     This will delete all custom settings and restore defaults from DEFAULT_GLOBAL_SETTINGS.
         *
         *     Returns:
         *         Status message
         */
        post: operations["reset_to_defaults_api_settings_reset_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/settings/segment-limits/{engine}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Segment Limits
         * @description Get effective segment length limits for text segmentation
         *
         *     Combines user preference with engine constraints to determine the actual limit to use.
         *
         *     Args:
         *         engine: Engine name
         *
         *     Returns:
         *         {
         *             "user_preference": 500,   # From settings
         *             "engine_maximum": 1000,   # From engine schema
         *             "effective_limit": 500    # Min of both
         *         }
         */
        get: operations["get_segment_limits_api_settings_segment_limits__engine__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/settings/engine-schema/{engine_type}/{engine}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Engine Parameter Schema By Type
         * @description Get parameter schema for any engine type
         *
         *     Returns UI metadata for engine parameters (for Settings dialog).
         *
         *     Args:
         *         engine_type: Type of engine ('tts', 'stt', 'text', 'audio')
         *         engine: Engine name
         *
         *     Returns:
         *         Parameter schema dictionary
         */
        get: operations["get_engine_parameter_schema_by_type_api_settings_engine_schema__engine_type___engine__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/settings/engine-schema/{engine}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Engine Parameter Schema
         * @description Get parameter schema for a specific TTS engine (legacy endpoint)
         *
         *     Returns UI metadata for engine parameters (for Settings dialog).
         *     DEPRECATED: Use /engine-schema/{engine_type}/{engine} instead.
         *
         *     Args:
         *         engine: Engine name
         *
         *     Returns:
         *         Parameter schema dictionary
         */
        get: operations["get_engine_parameter_schema_api_settings_engine_schema__engine__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/speakers/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Speakers
         * @description List all speakers with their samples
         *
         *     Returns a list of all speakers including metadata and sample information.
         */
        get: operations["list_speakers_api_speakers__get"];
        put?: never;
        /**
         * Create Speaker
         * @description Create a new speaker
         *
         *     Creates a new speaker with metadata. Audio samples can be added separately.
         *
         *     Args:
         *         request: Speaker data (name, description, gender, languages, tags)
         *
         *     Returns:
         *         Created speaker
         */
        post: operations["create_speaker_api_speakers__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/speakers/{speaker_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Speaker
         * @description Get speaker details
         *
         *     Returns full speaker information including all samples.
         *
         *     Args:
         *         speaker_id: Speaker ID
         *
         *     Returns:
         *         Speaker details
         */
        get: operations["get_speaker_api_speakers__speaker_id__get"];
        /**
         * Update Speaker
         * @description Update speaker metadata
         *
         *     Updates speaker information. Only provided fields will be updated.
         *
         *     Args:
         *         speaker_id: Speaker ID
         *         request: Fields to update
         *
         *     Returns:
         *         Updated speaker
         */
        put: operations["update_speaker_api_speakers__speaker_id__put"];
        post?: never;
        /**
         * Delete Speaker
         * @description Delete speaker and all samples
         *
         *     Permanently deletes a speaker including all audio samples and database records.
         *
         *     Args:
         *         speaker_id: Speaker ID
         *
         *     Returns:
         *         Status message
         */
        delete: operations["delete_speaker_api_speakers__speaker_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/speakers/{speaker_id}/set-default": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Set Default Speaker
         * @description Set a speaker as the default
         *
         *     Only one speaker can be default at a time.
         *     This will unset any other default speaker.
         *     Also updates settings.tts.defaultTtsSpeaker.
         *
         *     Args:
         *         speaker_id: Speaker ID to set as default
         *
         *     Returns:
         *         Updated speaker
         */
        post: operations["set_default_speaker_api_speakers__speaker_id__set_default_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/speakers/default/get": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Default Speaker
         * @description Get the default speaker
         *
         *     Returns:
         *         Default speaker or null if none set
         */
        get: operations["get_default_speaker_api_speakers_default_get_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/speakers/{speaker_id}/samples": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Upload Sample
         * @description Upload audio sample for speaker
         *
         *     Uploads a WAV or MP3 file as a voice sample for the speaker.
         *     Note: All samples are equal - no primary/secondary distinction.
         *
         *     Args:
         *         speaker_id: Speaker ID
         *         file: Audio file (WAV or MP3)
         *         transcript: Optional text transcript of the audio
         *
         *     Returns:
         *         Sample metadata
         */
        post: operations["upload_sample_api_speakers__speaker_id__samples_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/speakers/{speaker_id}/samples/{sample_id}/audio": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Sample Audio
         * @description Get speaker sample audio file
         *
         *     Streams the audio file for a specific speaker sample.
         *
         *     Args:
         *         speaker_id: Speaker ID
         *         sample_id: Sample ID
         *
         *     Returns:
         *         Audio file (WAV or MP3)
         */
        get: operations["get_sample_audio_api_speakers__speaker_id__samples__sample_id__audio_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/speakers/{speaker_id}/samples/{sample_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete Sample
         * @description Delete speaker sample
         *
         *     Permanently deletes an audio sample file and database record.
         *
         *     Args:
         *         speaker_id: Speaker ID
         *         sample_id: Sample ID
         *
         *     Returns:
         *         Status message
         */
        delete: operations["delete_sample_api_speakers__speaker_id__samples__sample_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/subscribe": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Subscribe To Events
         * @description Server-Sent Events endpoint for real-time updates.
         *
         *     **Channels:**
         *     - `jobs` - TTS job updates, segment updates, chapter content changes
         *     - `projects` - Project and chapter CRUD events
         *     - `export` - Export job updates
         *     - `import` - Import job updates
         *     - `health` - System health updates (30s interval)
         *     - `engines` - Engine status updates (15s interval, countdown timers)
         *     - `speakers` - Speaker management events
         *     - `settings` - Settings updates
         *     - `pronunciation` - Pronunciation rule events
         *     - `quality` - Quality analysis job events
         *
         *     **Default:** Subscribe to `jobs`, `health`, and `engines` channels if not specified.
         *
         *     **Event Types (jobs channel):**
         *     - `job.created/started/progress/completed/failed/cancelled`
         *     - `segment.started/completed/failed/updated/frozen/unfrozen`
         *     - `chapter.updated` - Chapter content changed (segment deletion/reorder)
         *
         *     **Event Types (projects channel):**
         *     - `project.created/updated/deleted`
         *     - `chapter.created/deleted/reordered/updated` - Chapter CRUD
         *
         *     **Event Types (engines channel):**
         *     - `engine.status` - Periodic status (every 15s, includes countdown timers)
         *     - `engine.starting/started/stopping/stopped`
         *     - `engine.enabled/disabled/error`
         *
         *     **Example:**
         *     ```
         *     GET /api/events/subscribe?channels=jobs,health,engines
         *     ```
         *
         *     **Response Format:**
         *     ```
         *     event: job.progress
         *     data: {"jobId": "job-123", "progress": 46.0, "status": "running"}
         *     id: a1b2c3d4-5678-90ab-cdef-1234567890ab
         *
         *     ```
         *
         *     **Keepalive:**
         *     - Server sends keepalive comments every 15 seconds
         *     - Prevents connection timeout
         *     - Format: `: keepalive`
         *
         *     **Client Disconnection:**
         *     - Automatic cleanup when client disconnects
         *     - No explicit unsubscribe needed
         *     - Resources freed immediately
         *
         *     **Notes:**
         *     - Connection stays open indefinitely
         *     - Use `EventSource` API in browsers
         *     - Supports multiple simultaneous connections
         *     - Each client gets unique ID
         */
        get: operations["subscribe_to_events_api_events_subscribe_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/pronunciation/rules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Rules
         * @description Get pronunciation rules filtered by criteria.
         */
        get: operations["get_rules_api_pronunciation_rules_get"];
        put?: never;
        /**
         * Create Rule
         * @description Create a new pronunciation rule.
         */
        post: operations["create_rule_api_pronunciation_rules_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/pronunciation/rules/{rule_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update Rule
         * @description Update a pronunciation rule.
         */
        put: operations["update_rule_api_pronunciation_rules__rule_id__put"];
        post?: never;
        /**
         * Delete Rule
         * @description Delete a pronunciation rule.
         */
        delete: operations["delete_rule_api_pronunciation_rules__rule_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/pronunciation/rules/test": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test Rules
         * @description Test pronunciation rules on sample text.
         */
        post: operations["test_rules_api_pronunciation_rules_test_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/pronunciation/rules/conflicts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Conflicts
         * @description Detect conflicting pronunciation rules.
         */
        get: operations["get_conflicts_api_pronunciation_rules_conflicts_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/pronunciation/rules/bulk": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Bulk Operations
         * @description Perform bulk operations on pronunciation rules.
         */
        post: operations["bulk_operations_api_pronunciation_rules_bulk_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/pronunciation/rules/export": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Export Rules
         * @description Export pronunciation rules as JSON.
         *
         *     Args:
         *         rule_ids: Optional list of specific rule IDs to export
         *         engine: Optional engine filter
         *         language: Optional language filter
         *
         *     Returns:
         *         JSON array of rules
         */
        get: operations["export_rules_api_pronunciation_rules_export_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/pronunciation/rules/import": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Import Rules
         * @description Import pronunciation rules from JSON.
         *
         *     Args:
         *         import_data: Dict with 'rules' array and 'mode' ('merge' or 'replace')
         *
         *     Returns:
         *         Import statistics
         */
        post: operations["import_rules_api_pronunciation_rules_import_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/pronunciation/rules/test-audio": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate Test Audio
         * @description Generate test audio with pronunciation rule applied.
         *
         *     Args:
         *         test_data: Dict with 'segmentId' and 'rule' to test
         *
         *     Returns:
         *         Audio path and metadata
         */
        post: operations["generate_test_audio_api_pronunciation_rules_test_audio_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/projects/import/preview": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Import Preview
         * @description Parse markdown file and return preview with validation
         *
         *     Args:
         *         file: Markdown file (.md)
         *         mapping_rules: JSON string with mapping configuration
         *         language: Language code for spaCy segmentation (default: en)
         *
         *     Returns:
         *         ImportPreviewResponse with parsed structure, segments, warnings, stats
         *
         *     Raises:
         *         HTTPException 400: Invalid markdown structure or parsing error
         */
        post: operations["get_import_preview_api_projects_import_preview_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/projects/import": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Execute Import
         * @description Execute markdown import and create/update project in database
         *
         *     Args:
         *         file: Markdown file (.md)
         *         mapping_rules: JSON string with mapping configuration
         *         language: Language code for spaCy segmentation (default: en)
         *         mode: 'new' (create new project) or 'merge' (add to existing)
         *         merge_target_id: Project ID for merge mode (required if mode=merge)
         *         selected_chapters: JSON array of chapter titles to import (empty = all)
         *         renamed_chapters: JSON object mapping original titles to new titles
         *         tts_engine: TTS engine identifier (e.g., 'xtts')
         *         tts_model_name: TTS model name (e.g., 'v2.0.2')
         *         tts_language: TTS language code (e.g., 'en', 'de')
         *         tts_speaker_name: Optional speaker name for voice cloning
         *
         *     Returns:
         *         ImportExecuteResponse with created/updated project
         *
         *     Raises:
         *         HTTPException 400: Invalid input, parsing error, or missing required params
         *         HTTPException 404: Target project not found (merge mode)
         *         HTTPException 500: Internal server error
         */
        post: operations["execute_import_api_projects_import_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/projects/import/epub/preview": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Epub Import Preview
         * @description Parse an EPUB file and return the same preview structure as the markdown import.
         *
         *     Steps:
         *     1. Read EPUB bytes and convert to markdown using EpubImporter.
         *     2. Run MarkdownParser with segmentation using conservative engine limits.
         *     3. Run ImportValidator to get warnings and stats.
         */
        post: operations["get_epub_import_preview_api_projects_import_epub_preview_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/projects/import/epub": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Execute Epub Import
         * @description Execute an EPUB import by converting to markdown and running the same
         *     import pipeline as markdown imports.
         *
         *     Args mirror the markdown /api/projects/import endpoint for consistency.
         */
        post: operations["execute_epub_import_api_projects_import_epub_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/quality/analyze/segment/{segment_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Analyze Segment
         * @description Create quality analysis job for a single segment.
         *
         *     Uses default engines from settings if not specified.
         */
        post: operations["analyze_segment_api_quality_analyze_segment__segment_id__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/quality/analyze/chapter/{chapter_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Analyze Chapter
         * @description Create quality analysis job for all segments in a chapter.
         *
         *     Queues job for processing by Quality Worker. Uses default engines if not specified.
         */
        post: operations["analyze_chapter_api_quality_analyze_chapter__chapter_id__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * AllEnginesStatusResponse
         * @description All engines grouped by type.
         *
         *     Used by /api/engines/status endpoint for Engine Management UI.
         */
        AllEnginesStatusResponse: {
            /**
             * Success
             * @description Whether operation succeeded
             */
            success: boolean;
            /**
             * Tts
             * @description TTS engines
             */
            tts?: components["schemas"]["EngineStatusInfo"][];
            /**
             * Text
             * @description Text processing engines
             */
            text?: components["schemas"]["EngineStatusInfo"][];
            /**
             * Stt
             * @description Speech-to-text engines
             */
            stt?: components["schemas"]["EngineStatusInfo"][];
            /**
             * Audio
             * @description Audio analysis engines
             */
            audio?: components["schemas"]["EngineStatusInfo"][];
            /**
             * Hasttsengine
             * @description At least one enabled TTS engine exists
             */
            hasTtsEngine: boolean;
            /**
             * Hastextengine
             * @description At least one enabled text engine exists
             */
            hasTextEngine: boolean;
            /**
             * Hassttengine
             * @description At least one enabled STT engine exists
             */
            hasSttEngine: boolean;
        };
        /**
         * AllSettingsResponse
         * @description Response for all global settings organized by category.
         */
        AllSettingsResponse: {
            /**
             * Engines
             * @description Global engine lifecycle settings
             */
            engines: {
                [key: string]: unknown;
            };
            /**
             * Tts
             * @description TTS-related settings
             */
            tts: {
                [key: string]: unknown;
            };
            /**
             * Audio
             * @description Audio processing settings
             */
            audio: {
                [key: string]: unknown;
            };
            /**
             * Text
             * @description Text processing settings
             */
            text: {
                [key: string]: unknown;
            };
            /**
             * Stt
             * @description STT (Speech-to-Text) settings
             */
            stt: {
                [key: string]: unknown;
            };
            /**
             * Quality
             * @description Quality analysis settings
             */
            quality: {
                [key: string]: unknown;
            };
            /**
             * Languages
             * @description Language-related settings
             */
            languages: {
                [key: string]: unknown;
            };
        };
        /**
         * AudioDurationResponse
         * @description Response for audio duration query.
         */
        AudioDurationResponse: {
            /**
             * Filepath
             * @description Audio file path queried
             */
            filePath: string;
            /**
             * Duration
             * @description Audio duration in seconds
             */
            duration: number;
        };
        /** Body_execute_epub_import_api_projects_import_epub_post */
        Body_execute_epub_import_api_projects_import_epub_post: {
            /**
             * File
             * Format: binary
             */
            file: string;
            /** Mapping Rules */
            mapping_rules: string;
            /**
             * Language
             * @default en
             */
            language: string;
            /** Mode */
            mode: string;
            /** Merge Target Id */
            merge_target_id?: string | null;
            /**
             * Selected Chapters
             * @default []
             */
            selected_chapters: string;
            /**
             * Renamed Chapters
             * @default {}
             */
            renamed_chapters: string;
            /** Tts Engine */
            tts_engine: string;
            /** Tts Model Name */
            tts_model_name: string;
            /** Tts Language */
            tts_language: string;
            /** Tts Speaker Name */
            tts_speaker_name?: string | null;
        };
        /** Body_execute_import_api_projects_import_post */
        Body_execute_import_api_projects_import_post: {
            /**
             * File
             * Format: binary
             */
            file: string;
            /** Mapping Rules */
            mapping_rules: string;
            /**
             * Language
             * @default en
             */
            language: string;
            /** Mode */
            mode: string;
            /** Merge Target Id */
            merge_target_id?: string | null;
            /**
             * Selected Chapters
             * @default []
             */
            selected_chapters: string;
            /**
             * Renamed Chapters
             * @default {}
             */
            renamed_chapters: string;
            /** Tts Engine */
            tts_engine: string;
            /** Tts Model Name */
            tts_model_name: string;
            /** Tts Language */
            tts_language: string;
            /** Tts Speaker Name */
            tts_speaker_name?: string | null;
        };
        /** Body_get_epub_import_preview_api_projects_import_epub_preview_post */
        Body_get_epub_import_preview_api_projects_import_epub_preview_post: {
            /**
             * File
             * Format: binary
             */
            file: string;
            /** Mapping Rules */
            mapping_rules: string;
            /**
             * Language
             * @default en
             */
            language: string;
        };
        /** Body_get_import_preview_api_projects_import_preview_post */
        Body_get_import_preview_api_projects_import_preview_post: {
            /**
             * File
             * Format: binary
             */
            file: string;
            /** Mapping Rules */
            mapping_rules: string;
            /**
             * Language
             * @default en
             */
            language: string;
        };
        /** Body_upload_sample_api_speakers__speaker_id__samples_post */
        Body_upload_sample_api_speakers__speaker_id__samples_post: {
            /**
             * File
             * Format: binary
             */
            file: string;
            /** Transcript */
            transcript?: string | null;
        };
        /**
         * CancelJobResponse
         * @description Response for job cancellation operations.
         */
        CancelJobResponse: {
            /**
             * Status
             * @description Cancellation status: cancelled, cancelling, cannot_cancel, not_found
             */
            status: string;
            /**
             * Jobid
             * @description Job identifier
             */
            jobId: string;
            /**
             * Message
             * @description Human-readable status message
             */
            message: string;
        };
        /** ChapterCreate */
        ChapterCreate: {
            /** Projectid */
            projectId: string;
            /** Title */
            title: string;
            /** Orderindex */
            orderIndex: number;
        };
        /**
         * ChapterGenerationStartResponse
         * @description Response when starting chapter-wide audio generation.
         */
        ChapterGenerationStartResponse: {
            /**
             * Status
             * @description Start status: started, already_running
             */
            status: string;
            /**
             * Chapterid
             * @description Chapter identifier
             */
            chapterId: string;
            /**
             * Engine
             * @description Engine being used
             */
            engine?: string | null;
            /**
             * Message
             * @description Human-readable message
             */
            message: string;
            /**
             * Progress
             * @description Current progress if already running
             */
            progress?: number | null;
        };
        /**
         * ChapterPreview
         * @description Preview of a chapter with statistics (segments not included for performance)
         */
        ChapterPreview: {
            /** Id */
            id: string;
            /** Title */
            title: string;
            /** Originaltitle */
            originalTitle: string;
            /** Orderindex */
            orderIndex: number;
            stats: components["schemas"]["ChapterStats"];
            /** Warnings */
            warnings: components["schemas"]["ImportWarning"][];
        };
        /**
         * ChapterResponse
         * @description Response model for a single chapter.
         *
         *     Chapters organize segments and belong to a project.
         */
        ChapterResponse: {
            /**
             * Id
             * @description Unique chapter identifier
             */
            id: string;
            /**
             * Projectid
             * @description Parent project ID
             */
            projectId: string;
            /**
             * Title
             * @description Chapter title
             */
            title: string;
            /**
             * Orderindex
             * @description Position within project (0-indexed)
             */
            orderIndex: number;
            /**
             * Createdat
             * @description ISO timestamp of creation
             */
            createdAt: string;
            /**
             * Updatedat
             * @description ISO timestamp of last update
             */
            updatedAt: string;
        };
        /**
         * ChapterStats
         * @description Chapter statistics (auto-converts snake_case  camelCase for frontend)
         */
        ChapterStats: {
            /**
             * Segmentcount
             * @description Total number of segments in chapter
             */
            segmentCount: number;
            /**
             * Totalchars
             * @description Total character count
             */
            totalChars: number;
            /**
             * Dividercount
             * @description Number of divider segments
             */
            dividerCount: number;
            /**
             * Failedcount
             * @description Number of oversized segments (sentences > max_length)
             */
            failedCount: number;
        };
        /** ChapterUpdate */
        ChapterUpdate: {
            /** Title */
            title?: string | null;
            /** Orderindex */
            orderIndex?: number | null;
        };
        /**
         * ChapterWithSegmentsResponse
         * @description Chapter response with nested segments.
         *
         *     Used when fetching a chapter with all its segments.
         */
        ChapterWithSegmentsResponse: {
            /**
             * Id
             * @description Unique chapter identifier
             */
            id: string;
            /**
             * Projectid
             * @description Parent project ID
             */
            projectId: string;
            /**
             * Title
             * @description Chapter title
             */
            title: string;
            /**
             * Orderindex
             * @description Position within project (0-indexed)
             */
            orderIndex: number;
            /**
             * Createdat
             * @description ISO timestamp of creation
             */
            createdAt: string;
            /**
             * Updatedat
             * @description ISO timestamp of last update
             */
            updatedAt: string;
            /**
             * Segments
             * @description All segments in this chapter
             */
            segments?: components["schemas"]["SegmentResponse"][];
        };
        /**
         * CleanupJobsResponse
         * @description Response for bulk job cleanup operations.
         */
        CleanupJobsResponse: {
            /**
             * Success
             * @description Whether cleanup succeeded
             */
            success: boolean;
            /**
             * Deleted
             * @description Number of jobs deleted
             */
            deleted: number;
        };
        /**
         * DeleteJobResponse
         * @description Response for single job deletion operations.
         */
        DeleteJobResponse: {
            /**
             * Success
             * @description Whether deletion succeeded
             */
            success: boolean;
            /**
             * Deleted
             * @description Deletion confirmation flag
             */
            deleted: boolean;
            /**
             * Jobid
             * @description Deleted job identifier
             */
            jobId: string;
        };
        /**
         * DeleteResponse
         * @description Response for delete operations.
         */
        DeleteResponse: {
            /**
             * Success
             * @description Whether deletion succeeded
             * @default true
             */
            success: boolean;
            /**
             * Message
             * @description Confirmation message
             */
            message: string;
        };
        /**
         * EngineSchemaResponse
         * @description Response for engine parameter schema.
         */
        EngineSchemaResponse: {
            /**
             * Parameters
             * @description Parameter schema dictionary for UI generation
             */
            parameters: {
                [key: string]: unknown;
            };
        };
        /**
         * EngineStartRequest
         * @description Request to start an engine with optional model
         */
        EngineStartRequest: {
            /** Modelname */
            modelName?: string | null;
        };
        /**
         * EngineStatusInfo
         * @description Detailed engine status for management UI.
         *
         *     Used by /api/engines/status endpoint to display engine status across all types.
         *
         *     Status Values (complete lifecycle):
         *         - 'disabled': Engine is disabled in settings (not available for use)
         *         - 'stopped': Engine is enabled but not running
         *         - 'starting': Engine server is being started (process launching, waiting for health check)
         *         - 'running': Engine server is running and healthy
         *         - 'stopping': Engine server is being stopped (shutdown in progress)
         *         - 'error': Engine encountered an error
         */
        EngineStatusInfo: {
            /**
             * Name
             * @description Unique engine identifier
             */
            name: string;
            /**
             * Displayname
             * @description Human-readable display name
             */
            displayName: string;
            /**
             * Version
             * @description Engine version
             */
            version: string;
            /**
             * Enginetype
             * @description Engine type: 'tts', 'text', 'stt', or 'audio'
             */
            engineType: string;
            /**
             * Isenabled
             * @description Whether engine is enabled in settings
             */
            isEnabled: boolean;
            /**
             * Isrunning
             * @description Whether engine server is currently running
             */
            isRunning: boolean;
            /**
             * Isdefault
             * @description True for default engine of its type
             * @default false
             */
            isDefault: boolean;
            /**
             * Status
             * @description Status: 'disabled', 'stopped', 'starting', 'running', 'stopping', 'error'
             */
            status: string;
            /**
             * Port
             * @description HTTP port if engine is running
             */
            port?: number | null;
            /**
             * Errormessage
             * @description Error message if status='error'
             */
            errorMessage?: string | null;
            /**
             * Idletimeoutseconds
             * @description Inactivity timeout in seconds (None = exempt from auto-stop)
             */
            idleTimeoutSeconds?: number | null;
            /**
             * Secondsuntilautostop
             * @description Seconds remaining until auto-stop (None = not applicable)
             */
            secondsUntilAutoStop?: number | null;
            /**
             * Keeprunning
             * @description Whether engine is kept running (prevents auto-stop)
             * @default false
             */
            keepRunning: boolean;
            /**
             * Supportedlanguages
             * @description Supported ISO language codes (filtered by allowedLanguages for TTS)
             */
            supportedLanguages?: string[];
            /**
             * Allsupportedlanguages
             * @description All supported ISO language codes (unfiltered, for Settings UI)
             */
            allSupportedLanguages?: string[];
            /**
             * Device
             * @description Device: 'cpu' or 'cuda'
             * @default cpu
             */
            device: string;
            /**
             * Availablemodels
             * @description List of available model names
             */
            availableModels?: string[];
            /**
             * Loadedmodel
             * @description Currently loaded model name
             */
            loadedModel?: string | null;
            /**
             * Defaultmodelname
             * @description Default model name from settings (per-engine)
             */
            defaultModelName?: string | null;
        };
        /**
         * ExportProgressResponse
         * @description Progress tracking for audio export jobs.
         */
        ExportProgressResponse: {
            /**
             * Jobid
             * @description Export job identifier
             */
            jobId: string;
            /**
             * Status
             * @description Job status: pending, running, completed, failed, cancelled
             */
            status: string;
            /**
             * Progress
             * @description Progress percentage (0.0-1.0)
             */
            progress: number;
            /**
             * Currentsegment
             * @description Current segment being processed
             */
            currentSegment: number;
            /**
             * Totalsegments
             * @description Total segments to export
             */
            totalSegments: number;
            /**
             * Message
             * @description Current status message
             */
            message: string;
            /**
             * Outputpath
             * @description URL/path to exported file (when completed)
             */
            outputPath?: string | null;
            /**
             * Filesize
             * @description File size in bytes (when completed)
             */
            fileSize?: number | null;
            /**
             * Duration
             * @description Total audio duration in seconds (when completed)
             */
            duration?: number | null;
            /**
             * Error
             * @description Error message (when failed)
             */
            error?: string | null;
        };
        /**
         * ExportRequest
         * @description Audio export request
         */
        ExportRequest: {
            /** Chapterid */
            chapterId: string;
            /**
             * Outputformat
             * @default mp3
             */
            outputFormat: string;
            /** Quality */
            quality?: string | null;
            /** Bitrate */
            bitrate?: string | null;
            /** Samplerate */
            sampleRate?: number | null;
            /**
             * Pausebetweensegments
             * @default 500
             */
            pauseBetweenSegments: number;
            /** Customfilename */
            customFilename?: string | null;
        };
        /**
         * ExportResponse
         * @description Response when starting an audio export job.
         */
        ExportResponse: {
            /**
             * Jobid
             * @description Unique export job identifier
             */
            jobId: string;
            /**
             * Status
             * @description Initial job status
             */
            status: string;
            /**
             * Message
             * @description Human-readable message
             */
            message: string;
        };
        /**
         * FreezeSegmentRequest
         * @description Request body for freezing/unfreezing a segment
         */
        FreezeSegmentRequest: {
            /** Freeze */
            freeze: boolean;
        };
        /**
         * GenerateChapterRequest
         * @description Request to generate entire chapter
         */
        GenerateChapterRequest: {
            /** Chapterid */
            chapterId: string;
            /**
             * Forceregenerate
             * @default false
             */
            forceRegenerate: boolean;
            /**
             * Overridesegmentsettings
             * @default false
             */
            overrideSegmentSettings: boolean;
            /** Ttsspeakername */
            ttsSpeakerName?: string | null;
            /** Language */
            language?: string | null;
            /** Ttsengine */
            ttsEngine?: string | null;
            /** Ttsmodelname */
            ttsModelName?: string | null;
            options?: components["schemas"]["TTSOptions"] | null;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /**
         * HealthResponse
         * @description Health check response.
         */
        HealthResponse: {
            /**
             * Status
             * @description Health status: ok, degraded, down
             * @default ok
             */
            status: string;
            /**
             * Version
             * @description Backend version
             */
            version: string;
            /**
             * Timestamp
             * @description Current server timestamp
             */
            timestamp: string;
            /**
             * Database
             * @description Database connectivity
             * @default true
             */
            database: boolean;
            /**
             * Ttsengines
             * @description Available TTS engines
             */
            ttsEngines?: string[];
            /**
             * Busy
             * @description Backend currently processing long-running operation
             * @default false
             */
            busy: boolean;
            /**
             * Activejobs
             * @description Number of active generation/export jobs
             * @default 0
             */
            activeJobs: number;
            /**
             * Hasttsengine
             * @description At least one enabled TTS engine exists (via engine.status)
             */
            hasTtsEngine?: boolean | null;
            /**
             * Hastextengine
             * @description At least one enabled text engine exists (via engine.status)
             */
            hasTextEngine?: boolean | null;
            /**
             * Hassttengine
             * @description At least one enabled STT engine exists (via engine.status)
             */
            hasSttEngine?: boolean | null;
        };
        /**
         * ImportExecuteResponse
         * @description Response for import execution (POST /api/projects/import)
         */
        ImportExecuteResponse: {
            /** @description Created or updated project with chapters and segments */
            project: components["schemas"]["ProjectWithChaptersResponse"];
            /**
             * Chapterscreated
             * @description Number of chapters created/added
             */
            chaptersCreated: number;
            /**
             * Segmentscreated
             * @description Total number of segments created
             */
            segmentsCreated: number;
        };
        /**
         * ImportPreviewResponse
         * @description Complete preview response for import
         */
        ImportPreviewResponse: {
            /** Isvalid */
            isValid: boolean;
            /** Project */
            project: {
                [key: string]: unknown;
            };
            /** Chapters */
            chapters: components["schemas"]["ChapterPreview"][];
            /** Globalwarnings */
            globalWarnings: components["schemas"]["ImportWarning"][];
            stats: components["schemas"]["ImportStats"];
        };
        /**
         * ImportStats
         * @description Overall import statistics
         */
        ImportStats: {
            /** Totalchapters */
            totalChapters: number;
            /** Totalsegments */
            totalSegments: number;
            /** Totalchars */
            totalChars: number;
            /** Estimatedduration */
            estimatedDuration?: string | null;
        };
        /**
         * ImportWarning
         * @description Warning or error from import validation
         */
        ImportWarning: {
            /** Type */
            type: string;
            /** Message */
            message: string;
            /**
             * Severity
             * @enum {string}
             */
            severity: "critical" | "warning" | "info";
        };
        /**
         * KeepRunningRequest
         * @description Request to set keep-running flag for an engine
         */
        KeepRunningRequest: {
            /** Keeprunning */
            keepRunning: boolean;
        };
        /**
         * MergeResponse
         * @description Response for audio merge preview operation.
         */
        MergeResponse: {
            /**
             * Success
             * @description Whether merge succeeded
             */
            success: boolean;
            /**
             * Audiopath
             * @description URL/path to merged audio file
             */
            audioPath: string;
            /**
             * Duration
             * @description Total duration in seconds
             */
            duration: number;
        };
        /**
         * MergeSegmentsRequest
         * @description Request model for merging segments
         */
        MergeSegmentsRequest: {
            /** Chapterid */
            chapterId: string;
            /**
             * Pausems
             * @default 500
             */
            pauseMs: number;
        };
        /**
         * MessageResponse
         * @description Generic success/error message response.
         */
        MessageResponse: {
            /**
             * Success
             * @description Whether operation succeeded
             */
            success: boolean;
            /**
             * Message
             * @description Human-readable message
             */
            message: string;
        };
        /** MoveChapterRequest */
        MoveChapterRequest: {
            /** Newprojectid */
            newProjectId: string;
            /** Neworderindex */
            newOrderIndex: number;
        };
        /** MoveSegmentRequest */
        MoveSegmentRequest: {
            /** Newchapterid */
            newChapterId: string;
            /** Neworderindex */
            newOrderIndex: number;
        };
        /** ProjectCreate */
        ProjectCreate: {
            /** Title */
            title: string;
            /**
             * Description
             * @default
             */
            description: string | null;
        };
        /**
         * ProjectResponse
         * @description Response model for a single project.
         *
         *     Projects are the top-level containers for audiobook organization.
         */
        ProjectResponse: {
            /**
             * Id
             * @description Unique project identifier
             */
            id: string;
            /**
             * Title
             * @description Project title
             */
            title: string;
            /**
             * Description
             * @description Optional project description
             */
            description?: string | null;
            /**
             * Orderindex
             * @description Display order (0-indexed)
             * @default 0
             */
            orderIndex: number;
            /**
             * Createdat
             * @description ISO timestamp of creation
             */
            createdAt: string;
            /**
             * Updatedat
             * @description ISO timestamp of last update
             */
            updatedAt: string;
        };
        /** ProjectUpdate */
        ProjectUpdate: {
            /** Title */
            title?: string | null;
            /** Description */
            description?: string | null;
        };
        /**
         * ProjectWithChaptersResponse
         * @description Project response with nested chapters (and optionally segments).
         *
         *     Used when fetching a project with all its hierarchical content.
         */
        ProjectWithChaptersResponse: {
            /**
             * Id
             * @description Unique project identifier
             */
            id: string;
            /**
             * Title
             * @description Project title
             */
            title: string;
            /**
             * Description
             * @description Optional project description
             */
            description?: string | null;
            /**
             * Orderindex
             * @description Display order (0-indexed)
             * @default 0
             */
            orderIndex: number;
            /**
             * Createdat
             * @description ISO timestamp of creation
             */
            createdAt: string;
            /**
             * Updatedat
             * @description ISO timestamp of last update
             */
            updatedAt: string;
            /**
             * Chapters
             * @description All chapters in this project with their segments
             */
            chapters?: components["schemas"]["ChapterWithSegmentsResponse"][];
        };
        /**
         * PronunciationBulkResponse
         * @description Response for bulk pronunciation rule operations.
         */
        PronunciationBulkResponse: {
            /**
             * Message
             * @description Operation status message
             */
            message: string;
            /**
             * Modified
             * @description Number of rules modified
             */
            modified: number;
        };
        /**
         * PronunciationConflict
         * @description Details of a conflicting pronunciation rule.
         */
        PronunciationConflict: {
            /**
             * Rule1
             * @description First conflicting rule (id, pattern, scope)
             */
            rule1: {
                [key: string]: string;
            };
            /**
             * Rule2
             * @description Second conflicting rule (id, pattern, scope)
             */
            rule2: {
                [key: string]: string;
            };
            /**
             * Reason
             * @description Conflict reason description
             */
            reason: string;
        };
        /**
         * PronunciationConflictsResponse
         * @description Response for pronunciation rule conflict detection.
         */
        PronunciationConflictsResponse: {
            /**
             * Conflicts
             * @description List of detected conflicts
             */
            conflicts: components["schemas"]["PronunciationConflict"][];
            /**
             * Total
             * @description Total number of conflicts
             */
            total: number;
        };
        /**
         * PronunciationExportRuleResponse
         * @description Response for a single exported pronunciation rule.
         */
        PronunciationExportRuleResponse: {
            /**
             * Pattern
             * @description The pattern to match
             */
            pattern: string;
            /**
             * Replacement
             * @description The replacement text
             */
            replacement: string;
            /**
             * Isregex
             * @description Whether pattern is a regex
             */
            isRegex: boolean;
            /**
             * Scope
             * @description Rule scope (global, engine, project)
             */
            scope: string;
            /**
             * Projectid
             * @description Project ID if scope is project
             */
            projectId?: string | null;
            /**
             * Enginename
             * @description Engine name if scope is engine
             */
            engineName?: string | null;
            /**
             * Language
             * @description Language code
             */
            language?: string | null;
            /**
             * Isactive
             * @description Whether rule is active
             */
            isActive: boolean;
            /**
             * Createdat
             * @description ISO timestamp of creation
             */
            createdAt: string;
            /**
             * Updatedat
             * @description ISO timestamp of last update
             */
            updatedAt: string;
        };
        /**
         * PronunciationImportResponse
         * @description Response for pronunciation rules import operation.
         */
        PronunciationImportResponse: {
            /**
             * Success
             * @description Whether import succeeded
             */
            success: boolean;
            /**
             * Imported
             * @description Number of rules successfully imported
             */
            imported: number;
            /**
             * Skipped
             * @description Number of rules skipped due to errors
             */
            skipped: number;
            /**
             * Message
             * @description Import summary message
             */
            message: string;
        };
        /**
         * PronunciationRuleCreate
         * @description Model for creating a pronunciation rule.
         */
        PronunciationRuleCreate: {
            /** Pattern */
            pattern: string;
            /** Replacement */
            replacement: string;
            /**
             * Isregex
             * @default false
             */
            isRegex: boolean;
            /**
             * Scope
             * @enum {string}
             */
            scope: "project_engine" | "engine";
            /** Projectid */
            projectId?: string | null;
            /** Enginename */
            engineName: string;
            /** Language */
            language: string;
            /**
             * Isactive
             * @default true
             */
            isActive: boolean;
        };
        /**
         * PronunciationRuleResponse
         * @description Response model for pronunciation rules.
         */
        PronunciationRuleResponse: {
            /**
             * Id
             * @description Unique rule identifier
             */
            id: string;
            /**
             * Pattern
             * @description Text pattern to match
             */
            pattern: string;
            /**
             * Replacement
             * @description Replacement text
             */
            replacement: string;
            /**
             * Isregex
             * @description Whether pattern is regex
             */
            isRegex: boolean;
            /**
             * Scope
             * @description Rule scope: project_engine, engine, or global
             */
            scope: string;
            /**
             * Projectid
             * @description Project ID (for project_engine scope)
             */
            projectId?: string | null;
            /**
             * Enginename
             * @description TTS engine name
             */
            engineName: string;
            /**
             * Language
             * @description Language code
             */
            language: string;
            /**
             * Isactive
             * @description Whether rule is active
             */
            isActive: boolean;
            /**
             * Createdat
             * @description ISO timestamp of creation
             */
            createdAt: string;
            /**
             * Updatedat
             * @description ISO timestamp of last update
             */
            updatedAt: string;
        };
        /**
         * PronunciationRuleUpdate
         * @description Model for updating a pronunciation rule.
         */
        PronunciationRuleUpdate: {
            /** Pattern */
            pattern?: string | null;
            /** Replacement */
            replacement?: string | null;
            /** Isregex */
            isRegex?: boolean | null;
            /** Scope */
            scope?: ("project_engine" | "engine") | null;
            /** Projectid */
            projectId?: string | null;
            /** Enginename */
            engineName?: string | null;
            /** Language */
            language?: string | null;
            /** Isactive */
            isActive?: boolean | null;
        };
        /**
         * PronunciationRulesListResponse
         * @description Response for listing pronunciation rules.
         */
        PronunciationRulesListResponse: {
            /**
             * Rules
             * @description List of pronunciation rules
             */
            rules: components["schemas"]["PronunciationRuleResponse"][];
            /**
             * Total
             * @description Total number of rules
             */
            total: number;
        };
        /**
         * PronunciationTestAudioResponse
         * @description Response for pronunciation rule audio testing.
         */
        PronunciationTestAudioResponse: {
            /**
             * Originaltext
             * @description Original segment text
             */
            originalText: string;
            /**
             * Transformedtext
             * @description Text after applying pronunciation rule
             */
            transformedText: string;
            /**
             * Rulesapplied
             * @description List of rules that were applied
             */
            rulesApplied: string[];
            /**
             * Audiopath
             * @description URL/path to generated test audio file
             */
            audioPath?: string | null;
            /**
             * Message
             * @description Status message
             */
            message: string;
        };
        /**
         * PronunciationTestResponse
         * @description Response for pronunciation rule testing.
         */
        PronunciationTestResponse: {
            /**
             * Originaltext
             * @description Original input text
             */
            originalText: string;
            /**
             * Transformedtext
             * @description Text after applying rules
             */
            transformedText: string;
            /**
             * Rulesapplied
             * @description List of rules that matched
             */
            rulesApplied: string[];
            /**
             * Wouldexceedlimit
             * @description Whether transformed text exceeds engine limit
             */
            wouldExceedLimit: boolean;
            /**
             * Chunksrequired
             * @description Number of chunks needed if split
             */
            chunksRequired: number;
        };
        /**
         * QualityJobCreatedResponse
         * @description Response when quality job is created.
         */
        QualityJobCreatedResponse: {
            /** Jobid */
            jobId: string;
            /** Message */
            message: string;
            /** Status */
            status: string;
        };
        /**
         * QualityJobResponse
         * @description Quality job status response.
         */
        QualityJobResponse: {
            /** Id */
            id: string;
            /** Jobtype */
            jobType: string;
            /** Status */
            status: string;
            /** Sttengine */
            sttEngine?: string | null;
            /** Sttmodelname */
            sttModelName?: string | null;
            /** Audioengine */
            audioEngine?: string | null;
            /** Language */
            language: string;
            /** Totalsegments */
            totalSegments: number;
            /** Processedsegments */
            processedSegments: number;
            /**
             * Failedsegments
             * @default 0
             */
            failedSegments: number;
            /** Currentsegmentid */
            currentSegmentId?: string | null;
            /** Chapterid */
            chapterId?: string | null;
            /** Segmentid */
            segmentId?: string | null;
            /** Segmentids */
            segmentIds?: components["schemas"]["QualityJobSegmentStatus"][] | null;
            /** Triggersource */
            triggerSource?: string | null;
            /** Errormessage */
            errorMessage?: string | null;
            /** Createdat */
            createdAt: string;
            /** Startedat */
            startedAt?: string | null;
            /** Completedat */
            completedAt?: string | null;
            /** Chaptertitle */
            chapterTitle?: string | null;
            /** Projecttitle */
            projectTitle?: string | null;
        };
        /**
         * QualityJobSegmentStatus
         * @description Segment status within a quality job.
         */
        QualityJobSegmentStatus: {
            /** Id */
            id: string;
            /** Jobstatus */
            jobStatus: string;
        };
        /**
         * QualityJobsListResponse
         * @description Response model for list of quality jobs.
         *
         *     Used by endpoints that return multiple jobs with optional filtering.
         */
        QualityJobsListResponse: {
            /**
             * Success
             * @description Whether the request was successful
             * @default true
             */
            success: boolean;
            /**
             * Jobs
             * @description List of quality jobs matching the query filters
             */
            jobs?: components["schemas"]["QualityJobResponse"][];
            /**
             * Count
             * @description Number of jobs returned (may be less than limit if filtered)
             */
            count: number;
        };
        /** ReorderChaptersRequest */
        ReorderChaptersRequest: {
            /** Chapterids */
            chapterIds: string[];
            /** Projectid */
            projectId: string;
        };
        /** ReorderProjectsRequest */
        ReorderProjectsRequest: {
            /** Projectids */
            projectIds: string[];
        };
        /**
         * ReorderResponse
         * @description Response for reorder operations.
         */
        ReorderResponse: {
            /**
             * Success
             * @description Whether reordering succeeded
             * @default true
             */
            success: boolean;
            /**
             * Message
             * @description Confirmation message
             */
            message: string;
            /**
             * Count
             * @description Number of items reordered
             */
            count?: number | null;
        };
        /** ReorderSegmentsRequest */
        ReorderSegmentsRequest: {
            /** Segmentids */
            segmentIds: string[];
            /** Chapterid */
            chapterId: string;
        };
        /**
         * RootResponse
         * @description Root endpoint response.
         */
        RootResponse: {
            /**
             * Name
             * @description API name
             */
            name: string;
            /**
             * Version
             * @description API version
             */
            version: string;
            /**
             * Status
             * @description API status
             */
            status: string;
        };
        /** SegmentCreate */
        SegmentCreate: {
            /** Chapterid */
            chapterId: string;
            /** Text */
            text: string;
            /** Orderindex */
            orderIndex: number;
            /**
             * Segmenttype
             * @default standard
             */
            segmentType: string;
            /**
             * Pauseduration
             * @default 0
             */
            pauseDuration: number;
            /**
             * Ttsengine
             * @default
             */
            ttsEngine: string;
            /**
             * Ttsmodelname
             * @default
             */
            ttsModelName: string;
            /** Ttsspeakername */
            ttsSpeakerName?: string | null;
            /**
             * Language
             * @default
             */
            language: string;
            /** Audiopath */
            audioPath?: string | null;
            /**
             * Starttime
             * @default 0
             */
            startTime: number;
            /**
             * Endtime
             * @default 0
             */
            endTime: number;
            /**
             * Status
             * @default pending
             */
            status: string;
        };
        /**
         * SegmentLimitsResponse
         * @description Response for effective segment length limits.
         */
        SegmentLimitsResponse: {
            /**
             * Userpreference
             * @description User's preferred max segment length from settings
             */
            userPreference: number;
            /**
             * Enginemaximum
             * @description Engine's maximum allowed text length
             */
            engineMaximum: number;
            /**
             * Effectivelimit
             * @description Effective limit to use (minimum of both)
             */
            effectiveLimit: number;
        };
        /**
         * SegmentQueueResponse
         * @description Response for segment queued for TTS generation.
         */
        SegmentQueueResponse: {
            /**
             * Success
             * @description Whether segment was queued successfully
             */
            success: boolean;
            /**
             * Jobid
             * @description ID of the created job
             */
            jobId: string;
            /**
             * Segmentid
             * @description ID of the segment queued
             */
            segmentId: string;
            /**
             * Message
             * @description Human-readable status message
             */
            message: string;
        };
        /** SegmentRequest */
        SegmentRequest: {
            /** Text */
            text: string;
            /**
             * Method
             * @default smart
             * @enum {string}
             */
            method: "sentences" | "paragraphs" | "smart" | "length";
            /**
             * Language
             * @default de
             */
            language: string;
            /**
             * Engine Name
             * @default
             */
            engine_name: string;
            /**
             * Min Length
             * @default 50
             */
            min_length: number;
            /**
             * Max Length
             * @default 500
             */
            max_length: number;
        };
        /**
         * SegmentResponse
         * @description Response model for a single segment.
         *
         *     Segments are the atomic units of an audiobook chapter, each representing
         *     a piece of text that will be converted to speech.
         */
        SegmentResponse: {
            /**
             * Id
             * @description Unique segment identifier
             */
            id: string;
            /**
             * Chapterid
             * @description Parent chapter ID
             */
            chapterId: string;
            /**
             * Text
             * @description Text content to be converted to speech
             */
            text: string;
            /**
             * Ttsengine
             * @description TTS engine used
             */
            ttsEngine: string;
            /**
             * Ttsmodelname
             * @description TTS model version
             */
            ttsModelName: string;
            /**
             * Ttsspeakername
             * @description Speaker/voice name
             */
            ttsSpeakerName?: string | null;
            /**
             * Language
             * @description Language code)
             */
            language: string;
            /**
             * Segmenttype
             * @description Segment type: 'standard' or 'divider'
             * @default standard
             */
            segmentType: string;
            /**
             * Pauseduration
             * @description Pause duration in milliseconds (for divider segments)
             * @default 0
             */
            pauseDuration: number;
            /**
             * Audiopath
             * @description URL/path to generated audio file
             */
            audioPath?: string | null;
            /**
             * Orderindex
             * @description Position within chapter (0-indexed)
             */
            orderIndex: number;
            /**
             * Starttime
             * @description Audio start time in seconds
             * @default 0
             */
            startTime: number;
            /**
             * Endtime
             * @description Audio end time in seconds
             * @default 0
             */
            endTime: number;
            /**
             * Status
             * @description Generation status: pending, processing, completed, failed
             * @default pending
             */
            status: string;
            /**
             * Isfrozen
             * @description Whether segment is frozen (protected from regeneration)
             * @default false
             */
            isFrozen: boolean;
            /**
             * Createdat
             * @description ISO timestamp of creation
             */
            createdAt: string;
            /**
             * Updatedat
             * @description ISO timestamp of last update
             */
            updatedAt: string;
            /**
             * Qualityanalyzed
             * @description Whether segment has been analyzed by Quality system
             */
            qualityAnalyzed?: boolean | null;
            /**
             * Qualityscore
             * @description Aggregated quality score (0-100)
             */
            qualityScore?: number | null;
            /**
             * Qualitystatus
             * @description Quality status: 'perfect', 'warning', or 'defect'
             */
            qualityStatus?: string | null;
            /**
             * Engineresults
             * @description Results from each quality engine in generic format
             */
            engineResults?: {
                [key: string]: unknown;
            }[] | null;
        };
        /** SegmentTextRequest */
        SegmentTextRequest: {
            /** Text */
            text: string;
            /** Language */
            language: string;
            /** Ttsengine */
            ttsEngine: string;
            /** Ttsmodelname */
            ttsModelName: string;
            /** Ttslanguage */
            ttsLanguage?: string | null;
            /** Ttsspeakername */
            ttsSpeakerName?: string | null;
            /** Minlength */
            minLength?: number | null;
            /** Maxlength */
            maxLength?: number | null;
        };
        /**
         * SegmentTextResponse
         * @description Response for text segmentation endpoint
         */
        SegmentTextResponse: {
            /** Success */
            success: boolean;
            /** Method */
            method: string;
            /** Language */
            language: string;
            /** Segmentcount */
            segmentCount: number;
            /** Segments */
            segments: string[];
        };
        /** SegmentUpdate */
        SegmentUpdate: {
            /** Text */
            text?: string | null;
            /** Audiopath */
            audioPath?: string | null;
            /** Starttime */
            startTime?: number | null;
            /** Endtime */
            endTime?: number | null;
            /** Status */
            status?: string | null;
            /** Pauseduration */
            pauseDuration?: number | null;
            /** Ttsengine */
            ttsEngine?: string | null;
            /** Ttsmodelname */
            ttsModelName?: string | null;
            /** Language */
            language?: string | null;
            /** Ttsspeakername */
            ttsSpeakerName?: string | null;
        };
        /**
         * SettingUpdateRequest
         * @description Request model for updating settings
         */
        SettingUpdateRequest: {
            /** Value */
            value: {
                [key: string]: unknown;
            };
        };
        /**
         * SettingValueResponse
         * @description Response for single setting value.
         */
        SettingValueResponse: {
            /**
             * Key
             * @description Setting key (supports dot notation)
             */
            key: string;
            /**
             * Value
             * @description Setting value (can be any JSON type)
             */
            value: unknown;
        };
        /**
         * SpeakerCreateRequest
         * @description Request model for creating a speaker
         */
        SpeakerCreateRequest: {
            /** Name */
            name: string;
            /** Description */
            description?: string | null;
            /** Gender */
            gender?: string | null;
            /**
             * Languages
             * @default []
             */
            languages: string[];
            /**
             * Tags
             * @default []
             */
            tags: string[];
        };
        /**
         * SpeakerResponse
         * @description Response model for a speaker.
         *
         *     Speakers represent different voices available for TTS generation.
         */
        SpeakerResponse: {
            /**
             * Id
             * @description Unique speaker identifier
             */
            id: string;
            /**
             * Name
             * @description Speaker name
             */
            name: string;
            /**
             * Description
             * @description Optional speaker description
             */
            description?: string | null;
            /**
             * Gender
             * @description Speaker gender: male, female, neutral
             */
            gender?: string | null;
            /**
             * Languages
             * @description Supported languages
             */
            languages?: string[];
            /**
             * Tags
             * @description Organizational tags
             */
            tags?: string[];
            /**
             * Isdefault
             * @description Whether this is the default speaker
             * @default false
             */
            isDefault: boolean;
            /**
             * Isactive
             * @description Whether speaker has samples (auto-computed)
             */
            isActive: boolean;
            /**
             * Samplecount
             * @description Number of voice samples
             * @default 0
             */
            sampleCount: number;
            /**
             * Createdat
             * @description ISO timestamp of creation
             */
            createdAt: string;
            /**
             * Updatedat
             * @description ISO timestamp of last update
             */
            updatedAt: string;
            /**
             * Samples
             * @description Voice samples for this speaker
             */
            samples?: components["schemas"]["SpeakerSampleResponse"][];
        };
        /**
         * SpeakerSampleResponse
         * @description Response model for a speaker voice sample.
         *
         *     Samples are audio files used for voice cloning.
         */
        SpeakerSampleResponse: {
            /**
             * Id
             * @description Unique sample identifier
             */
            id: string;
            /**
             * Speakerid
             * @description Parent speaker ID (optional when nested)
             */
            speakerId?: string | null;
            /**
             * Filepath
             * @description URL/path to audio sample file
             */
            filePath: string;
            /**
             * Filename
             * @description Original filename
             */
            fileName: string;
            /**
             * Filesize
             * @description File size in bytes
             */
            fileSize: number;
            /**
             * Duration
             * @description Audio duration in seconds
             */
            duration?: number | null;
            /**
             * Samplerate
             * @description Audio sample rate in Hz
             */
            sampleRate?: number | null;
            /**
             * Transcript
             * @description Optional transcript
             */
            transcript?: string | null;
            /**
             * Createdat
             * @description ISO timestamp of upload
             */
            createdAt: string;
        };
        /**
         * SpeakerUpdateRequest
         * @description Request model for updating a speaker
         */
        SpeakerUpdateRequest: {
            /** Name */
            name?: string | null;
            /** Description */
            description?: string | null;
            /** Gender */
            gender?: string | null;
            /** Languages */
            languages?: string[] | null;
            /** Tags */
            tags?: string[] | null;
        };
        /**
         * TTSJobResponse
         * @description Response model for a single TTS job (database-backed).
         *
         *     TTS jobs represent generation tasks that are persisted in the database
         *     and processed by the background worker. They can be chapter-wide or
         *     segment-specific.
         */
        TTSJobResponse: {
            /**
             * Id
             * @description Unique job identifier (UUID)
             */
            id: string;
            /**
             * Chapterid
             * @description Chapter being processed (context for UI navigation)
             */
            chapterId?: string | null;
            /**
             * Segmentids
             * @description Parsed segment objects with job_status: [{'id': 'seg-1', 'job_status': 'pending'}, ...]
             */
            segmentIds?: {
                [key: string]: unknown;
            }[] | null;
            /**
             * Chaptertitle
             * @description Chapter title (for UI display)
             */
            chapterTitle?: string | null;
            /**
             * Projecttitle
             * @description Project title (for UI display)
             */
            projectTitle?: string | null;
            /**
             * Ttsengine
             * @description TTS engine identifier
             */
            ttsEngine: string;
            /**
             * Ttsmodelname
             * @description TTS model name
             */
            ttsModelName: string;
            /**
             * Ttsspeakername
             * @description Speaker/voice name
             */
            ttsSpeakerName: string;
            /**
             * Language
             * @description Language code
             */
            language: string;
            /**
             * Forceregenerate
             * @description Whether to regenerate already completed segments
             */
            forceRegenerate: boolean;
            /**
             * Status
             * @description Job status: 'pending', 'running', 'cancelling', 'cancelled', 'completed', 'failed'
             */
            status: string;
            /**
             * Totalsegments
             * @description Total number of segments to process
             */
            totalSegments: number;
            /**
             * Processedsegments
             * @description Number of segments successfully processed
             * @default 0
             */
            processedSegments: number;
            /**
             * Failedsegments
             * @description Number of segments that failed
             * @default 0
             */
            failedSegments: number;
            /**
             * Currentsegmentid
             * @description ID of segment currently being processed
             */
            currentSegmentId?: string | null;
            /**
             * Errormessage
             * @description Error details if job failed
             */
            errorMessage?: string | null;
            /**
             * Retrycount
             * @description Number of retry attempts
             * @default 0
             */
            retryCount: number;
            /**
             * Createdat
             * @description Job creation timestamp (ISO 8601)
             */
            createdAt: string;
            /**
             * Startedat
             * @description Job start timestamp (ISO 8601)
             */
            startedAt?: string | null;
            /**
             * Completedat
             * @description Job completion timestamp (ISO 8601)
             */
            completedAt?: string | null;
            /**
             * Updatedat
             * @description Last update timestamp (ISO 8601)
             */
            updatedAt: string;
        };
        /**
         * TTSJobsListResponse
         * @description Response model for list of TTS jobs.
         *
         *     Used by endpoints that return multiple jobs with optional filtering.
         */
        TTSJobsListResponse: {
            /**
             * Success
             * @description Whether the request was successful
             * @default true
             */
            success: boolean;
            /**
             * Jobs
             * @description List of TTS jobs matching the query filters
             */
            jobs?: components["schemas"]["TTSJobResponse"][];
            /**
             * Count
             * @description Number of jobs returned (may be less than limit if filtered)
             */
            count: number;
        };
        /**
         * TTSOptions
         * @description TTS generation options (optional overrides)
         */
        TTSOptions: {
            /** Temperature */
            temperature?: number | null;
            /** Lengthpenalty */
            lengthPenalty?: number | null;
            /** Repetitionpenalty */
            repetitionPenalty?: number | null;
            /** Topk */
            topK?: number | null;
            /** Topp */
            topP?: number | null;
            /** Speed */
            speed?: number | null;
        };
        /**
         * TextSegmentationResponse
         * @description Response for text segmentation operations.
         */
        TextSegmentationResponse: {
            /**
             * Success
             * @description Whether operation succeeded
             */
            success: boolean;
            /**
             * Message
             * @description Status message
             */
            message: string;
            /**
             * Segments
             * @description Created segments
             */
            segments?: components["schemas"]["SegmentResponse"][];
            /**
             * Segmentcount
             * @description Number of segments
             */
            segmentCount: number;
            /**
             * Engine
             * @description Engine used for constraints
             */
            engine: string;
            /**
             * Constraints
             * @description Min/max length constraints applied
             */
            constraints: {
                [key: string]: number;
            };
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    health_check_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HealthResponse"];
                };
            };
        };
    };
    root__get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RootResponse"];
                };
            };
        };
    };
    generate_segment_by_id_api_tts_generate_segment__segment_id__post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                segment_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SegmentQueueResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    generate_chapter_api_tts_generate_chapter_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GenerateChapterRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ChapterGenerationStartResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_tts_jobs_api_jobs_tts__get: {
        parameters: {
            query?: {
                status?: string | null;
                chapter_id?: string | null;
                limit?: number;
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TTSJobsListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_active_tts_jobs_api_jobs_tts_active_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TTSJobsListResponse"];
                };
            };
        };
    };
    get_tts_job_api_jobs_tts__job_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TTSJobResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_tts_job_api_jobs_tts__job_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteJobResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cleanup_tts_jobs_api_jobs_tts_cleanup_delete: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CleanupJobsResponse"];
                };
            };
        };
    };
    cancel_tts_job_api_jobs_tts__job_id__cancel_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CancelJobResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    resume_tts_job_api_jobs_tts__job_id__resume_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TTSJobResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_quality_jobs_api_jobs_quality__get: {
        parameters: {
            query?: {
                status?: string | null;
                chapter_id?: string | null;
                limit?: number;
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QualityJobsListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_active_quality_jobs_api_jobs_quality_active_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QualityJobsListResponse"];
                };
            };
        };
    };
    get_quality_job_api_jobs_quality__job_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QualityJobResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_quality_job_api_jobs_quality__job_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cancel_quality_job_api_jobs_quality__job_id__cancel_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cleanup_quality_jobs_api_jobs_quality_cleanup_delete: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CleanupJobsResponse"];
                };
            };
        };
    };
    resume_quality_job_api_jobs_quality__job_id__resume_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QualityJobResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_all_engines_status_api_engines_status_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AllEnginesStatusResponse"];
                };
            };
        };
    };
    enable_engine_api_engines__engine_type___engine_name__enable_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                engine_type: string;
                engine_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    disable_engine_api_engines__engine_type___engine_name__disable_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                engine_type: string;
                engine_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    start_engine_api_engines__engine_type___engine_name__start_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                engine_type: string;
                engine_name: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["EngineStartRequest"] | null;
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    stop_engine_api_engines__engine_type___engine_name__stop_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                engine_type: string;
                engine_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    set_default_engine_api_engines__engine_type__default__engine_name__post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                engine_type: string;
                engine_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    clear_default_engine_api_engines__engine_type__default_delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                engine_type: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    set_engine_keep_running_api_engines__engine_type___engine_name__keep_running_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                engine_type: string;
                engine_name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["KeepRunningRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_all_projects_api_projects_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProjectWithChaptersResponse"][];
                };
            };
        };
    };
    create_project_api_projects_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProjectCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProjectResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_project_api_projects__project_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                project_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProjectWithChaptersResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_project_api_projects__project_id__put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                project_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProjectUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProjectWithChaptersResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_project_api_projects__project_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                project_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    reorder_projects_api_projects_reorder_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReorderProjectsRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReorderResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_chapter_api_chapters_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChapterCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ChapterResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_chapter_api_chapters__chapter_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                chapter_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ChapterWithSegmentsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_chapter_api_chapters__chapter_id__put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                chapter_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChapterUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ChapterWithSegmentsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_chapter_api_chapters__chapter_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                chapter_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    segment_chapter_text_api_chapters__chapter_id__segment_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                chapter_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SegmentTextRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TextSegmentationResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    reorder_chapters_api_chapters_reorder_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReorderChaptersRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReorderResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    move_chapter_api_chapters__chapter_id__move_put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                chapter_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MoveChapterRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ChapterWithSegmentsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_segment_api_segments_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SegmentCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SegmentResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_segment_api_segments__segment_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                segment_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SegmentResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_segment_api_segments__segment_id__put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                segment_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SegmentUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SegmentResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_segment_api_segments__segment_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                segment_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    reorder_segments_api_segments_reorder_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReorderSegmentsRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReorderResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    move_segment_api_segments__segment_id__move_put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                segment_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MoveSegmentRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SegmentResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    toggle_freeze_segment_api_segments__segment_id__freeze_patch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                segment_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FreezeSegmentRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SegmentResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    segment_text_api_text_segment_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SegmentRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SegmentTextResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    start_export_api_audio_export_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ExportRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExportResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_export_progress_api_audio_export__job_id__progress_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExportProgressResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cancel_export_api_audio_export__job_id__cancel_delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    download_export_api_audio_export__job_id__download_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_export_api_audio_export__job_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    merge_segments_api_audio_merge_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MergeSegmentsRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MergeResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_audio_duration_api_audio_duration__file_path__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                file_path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AudioDurationResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_audio_file_api_audio__file_path__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                file_path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_all_settings_api_settings__get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AllSettingsResponse"];
                };
            };
        };
    };
    get_setting_api_settings__key__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SettingValueResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_setting_api_settings__key__put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                key: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SettingUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SettingValueResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    reset_to_defaults_api_settings_reset_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
        };
    };
    get_segment_limits_api_settings_segment_limits__engine__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                engine: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SegmentLimitsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_engine_parameter_schema_by_type_api_settings_engine_schema__engine_type___engine__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                engine_type: string;
                engine: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EngineSchemaResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_engine_parameter_schema_api_settings_engine_schema__engine__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                engine: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EngineSchemaResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_speakers_api_speakers__get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SpeakerResponse"][];
                };
            };
        };
    };
    create_speaker_api_speakers__post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SpeakerCreateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SpeakerResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_speaker_api_speakers__speaker_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                speaker_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SpeakerResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_speaker_api_speakers__speaker_id__put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                speaker_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SpeakerUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SpeakerResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_speaker_api_speakers__speaker_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                speaker_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    set_default_speaker_api_speakers__speaker_id__set_default_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                speaker_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SpeakerResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_default_speaker_api_speakers_default_get_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SpeakerResponse"] | null;
                };
            };
        };
    };
    upload_sample_api_speakers__speaker_id__samples_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                speaker_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["Body_upload_sample_api_speakers__speaker_id__samples_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SpeakerSampleResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_sample_audio_api_speakers__speaker_id__samples__sample_id__audio_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                speaker_id: string;
                sample_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_sample_api_speakers__speaker_id__samples__sample_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                speaker_id: string;
                sample_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    subscribe_to_events_api_events_subscribe_get: {
        parameters: {
            query?: {
                /** @description Comma-separated list of channels to subscribe to (e.g., 'jobs,health,engines') */
                channels?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_rules_api_pronunciation_rules_get: {
        parameters: {
            query?: {
                engine?: string | null;
                language?: string | null;
                project_id?: string | null;
                scope?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PronunciationRulesListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_rule_api_pronunciation_rules_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PronunciationRuleCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PronunciationRuleResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_rule_api_pronunciation_rules__rule_id__put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PronunciationRuleUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PronunciationRuleResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_rule_api_pronunciation_rules__rule_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    test_rules_api_pronunciation_rules_test_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    [key: string]: unknown;
                };
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PronunciationTestResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_conflicts_api_pronunciation_rules_conflicts_get: {
        parameters: {
            query: {
                engine: string;
                language: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PronunciationConflictsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    bulk_operations_api_pronunciation_rules_bulk_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    [key: string]: unknown;
                };
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PronunciationBulkResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    export_rules_api_pronunciation_rules_export_get: {
        parameters: {
            query?: {
                rule_ids?: string[] | null;
                engine?: string | null;
                language?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PronunciationExportRuleResponse"][];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    import_rules_api_pronunciation_rules_import_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    [key: string]: unknown;
                };
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PronunciationImportResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    generate_test_audio_api_pronunciation_rules_test_audio_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    [key: string]: unknown;
                };
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PronunciationTestAudioResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_import_preview_api_projects_import_preview_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["Body_get_import_preview_api_projects_import_preview_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ImportPreviewResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    execute_import_api_projects_import_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["Body_execute_import_api_projects_import_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ImportExecuteResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_epub_import_preview_api_projects_import_epub_preview_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["Body_get_epub_import_preview_api_projects_import_epub_preview_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ImportPreviewResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    execute_epub_import_api_projects_import_epub_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["Body_execute_epub_import_api_projects_import_epub_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ImportExecuteResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    analyze_segment_api_quality_analyze_segment__segment_id__post: {
        parameters: {
            query?: {
                stt_engine?: string | null;
                stt_model_name?: string | null;
                audio_engine?: string | null;
            };
            header?: never;
            path: {
                segment_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QualityJobCreatedResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    analyze_chapter_api_quality_analyze_chapter__chapter_id__post: {
        parameters: {
            query?: {
                stt_engine?: string | null;
                stt_model_name?: string | null;
                audio_engine?: string | null;
            };
            header?: never;
            path: {
                chapter_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QualityJobCreatedResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
}
